local a=20140920.13;local b="-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json) version 20140920.13 ]-"local OBJDEF={VERSION=a,AUTHOR_NOTE=b}local c={__tostring=function()return"JSON array"end}c.__index=c;local d={__tostring=function()return"JSON object"end}d.__index=d;function OBJDEF:newArray(e)return setmetatable(e or{},c)end;function OBJDEF:newObject(e)return setmetatable(e or{},d)end;local function f(g)if g<=127 then return string.char(g)elseif g<=2047 then local h=math.floor(g/0x40)local i=g-0x40*h;return string.char(0xC0+h,0x80+i)elseif g<=65535 then local h=math.floor(g/0x1000)local j=g-0x1000*h;local k=math.floor(j/0x40)local i=j-0x40*k;h=0xE0+h;k=0x80+k;i=0x80+i;if h==0xE0 and k<0xA0 or h==0xED and k>0x9F or h==0xF0 and k<0x90 or h==0xF4 and k>0x8F then return"?"else return string.char(h,k,i)end else local h=math.floor(g/0x40000)local j=g-0x40000*h;local l=math.floor(j/0x1000)j=j-0x1000*l;local m=math.floor(j/0x40)local i=j-0x40*m;return string.char(0xF0+h,0x80+l,0x80+m,0x80+i)end end;function OBJDEF:onDecodeError(n,o,p,q)if o then if p then n=string.format("%s at char %d of: %s",n,p,o)else n=string.format("%s: %s",n,o)end end;if q~=nil then n=n.." ("..OBJDEF:encode(q)..")"end;if self.assert then self.assert(false,n)else assert(false,n)end end;OBJDEF.onDecodeOfNilError=OBJDEF.onDecodeError;OBJDEF.onDecodeOfHTMLError=OBJDEF.onDecodeError;function OBJDEF:onEncodeError(n,q)if q~=nil then n=n.." ("..OBJDEF:encode(q)..")"end;if self.assert then self.assert(false,n)else assert(false,n)end end;local function r(self,o,s,q)local t=o:match('^-?[1-9]%d*',s)or o:match("^-?0",s)if not t then self:onDecodeError("expected number",o,s,q)end;local u=s+t:len()local v=o:match('^%.%d+',u)or""u=u+v:len()local w=o:match('^[eE][-+]?%d+',u)or""u=u+w:len()local x=t..v..w;local y=tonumber(x)if not y then self:onDecodeError("bad number",o,s,q)end;return y,u end;local function z(self,o,s,q)if o:sub(s,s)~='"'then self:onDecodeError("expected string's opening quote",o,s,q)end;local u=s+1;local A=o:len()local B=""while u<=A do local C=o:sub(u,u)if C=='"'then return B,u+1 end;if C~='\\'then B=B..C;u=u+1 elseif o:match('^\\b',u)then B=B.."\b"u=u+2 elseif o:match('^\\f',u)then B=B.."\f"u=u+2 elseif o:match('^\\n',u)then B=B.."\n"u=u+2 elseif o:match('^\\r',u)then B=B.."\r"u=u+2 elseif o:match('^\\t',u)then B=B.."\t"u=u+2 else local D=o:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',u)if D then u=u+6;local g=tonumber(D,16)if g>=0xD800 and g<=0xDBFF then local E=o:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',u)if E then u=u+6;g=0x2400+(g-0xD800)*0x400+tonumber(E,16)else end end;B=B..f(g)else B=B..o:match('^\\(.)',u)u=u+2 end end end;self:onDecodeError("unclosed string",o,s,q)end;local function F(o,s)local G,H=o:find("^[ \n\r\t]+",s)if H then return H+1 else return s end end;local I;local function J(self,o,s,q)if o:sub(s,s)~='{'then self:onDecodeError("expected '{'",o,s,q)end;local u=F(o,s+1)local B=self.strictTypes and self:newObject{}or{}if o:sub(u,u)=='}'then return B,u+1 end;local A=o:len()while u<=A do local K,L=z(self,o,u,q)u=F(o,L)if o:sub(u,u)~=':'then self:onDecodeError("expected colon",o,u,q)end;u=F(o,u+1)local M,L=I(self,o,u)B[K]=M;u=F(o,L)local C=o:sub(u,u)if C=='}'then return B,u+1 end;if o:sub(u,u)~=','then self:onDecodeError("expected comma or '}'",o,u,q)end;u=F(o,u+1)end;self:onDecodeError("unclosed '{'",o,s,q)end;local function N(self,o,s,q)if o:sub(s,s)~='['then self:onDecodeError("expected '['",o,s,q)end;local u=F(o,s+1)local B=self.strictTypes and self:newArray{}or{}if o:sub(u,u)==']'then return B,u+1 end;local O=1;local A=o:len()while u<=A do local P,L=I(self,o,u)B[O]=P;O=O+1;u=F(o,L)local C=o:sub(u,u)if C==']'then return B,u+1 end;if o:sub(u,u)~=','then self:onDecodeError("expected comma or '['",o,u,q)end;u=F(o,u+1)end;self:onDecodeError("unclosed '['",o,s,q)end;I=function(self,o,s,q)s=F(o,s)if s>o:len()then self:onDecodeError("unexpected end of string",o,nil,q)end;if o:find('^"',s)then return z(self,o,s,q)elseif o:find('^[-0123456789 ]',s)then return r(self,o,s,q)elseif o:find('^%{',s)then return J(self,o,s,q)elseif o:find('^%[',s)then return N(self,o,s,q)elseif o:find('^true',s)then return true,s+4 elseif o:find('^false',s)then return false,s+5 elseif o:find('^null',s)then return nil,s+4 else self:onDecodeError("can't parse JSON",o,s,q)end end;function OBJDEF:decode(o,q)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onDecodeError("JSON:decode must be called in method format",nil,nil,q)end;if o==nil then self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"),nil,nil,q)elseif type(o)~='string'then self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s",type(o)),nil,nil,q)end;if o:match('^%s*$')then return nil end;if o:match('^%s*<')then self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"),o,nil,q)end;if o:sub(1,1):byte()==0 or o:len()>=2 and o:sub(2,2):byte()==0 then self:onDecodeError("JSON package groks only UTF-8, sorry",o,nil,q)end;local Q,R=pcall(I,self,o,1,q)if Q then return R else if self.assert then self.assert(false,R)else assert(false,R)end;return nil,R end end;local function S(C)if C=="\n"then return"\\n"elseif C=="\r"then return"\\r"elseif C=="\t"then return"\\t"elseif C=="\b"then return"\\b"elseif C=="\f"then return"\\f"elseif C=='"'then return'\\"'elseif C=='\\'then return'\\\\'else return string.format("\\u%04x",C:byte())end end;local T='['..'"'..'%\\'..'%z'..'\001'..'-'..'\031'..']'local function U(R)local V=R:gsub(T,S)return'"'..V..'"'end;local function W(self,X,q)local Y={}local Z={}local _=false;local a0;for K in pairs(X)do if type(K)=='string'then table.insert(Y,K)elseif type(K)=='number'then table.insert(Z,K)if K<=0 or K>=math.huge then _=true elseif not a0 or K>a0 then a0=K end else self:onEncodeError("can't encode table with a key of type "..type(K),q)end end;if#Y==0 and not _ then if#Z>0 then return nil,a0 elseif tostring(X)=="JSON array"then return nil elseif tostring(X)=="JSON object"then return{}else return nil end end;table.sort(Y)local a1;if#Z>0 then if self.noKeyConversion then self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting",q)end;a1={}for K,P in pairs(X)do a1[K]=P end;table.sort(Z)for G,a2 in ipairs(Z)do local a3=tostring(a2)if a1[a3]==nil then table.insert(Y,a3)a1[a3]=X[a2]else self:onEncodeError("conflict converting table with mixed-type keys into a JSON object: key "..a2 .." exists both as a string and a number.",q)end end end;return Y,nil,a1 end;local encode_value;function encode_value(self,R,a4,q,a5)if R==nil then return'null'elseif type(R)=='string'then return U(R)elseif type(R)=='number'then if R~=R then return"null"elseif R>=math.huge then return"1e+9999"elseif R<=-math.huge then return"-1e+9999"else return tostring(R)end elseif type(R)=='boolean'then return tostring(R)elseif type(R)~='table'then self:onEncodeError("can't convert "..type(R).." to JSON",q)else local X=R;if a4[X]then self:onEncodeError("table "..tostring(X).." is a child of itself",q)else a4[X]=true end;local a6;local a7,a0,a1=W(self,X,q)if a0 then local a8={}for u=1,a0 do table.insert(a8,encode_value(self,X[u],a4,q,a5))end;if a5 then a6="[ "..table.concat(a8,", ").." ]"else a6="["..table.concat(a8,",").."]"end elseif a7 then local a9=a1 or X;if a5 then local aa={}local ab=0;for G,K in ipairs(a7)do local ac=encode_value(self,tostring(K),a4,q,"")ab=math.max(ab,#ac)table.insert(aa,ac)end;local ad=a5 .."    "local ae=a5 ..string.rep(" ",ab+2+4)local af="%s%"..string.format("%d",ab).."s: %s"local ag={}for u,K in ipairs(a7)do local ah=encode_value(self,a9[K],a4,q,ae)table.insert(ag,string.format(af,ad,aa[u],ah))end;a6="{\n"..table.concat(ag,",\n").."\n"..a5 .."}"else local ai={}for G,K in ipairs(a7)do local ah=encode_value(self,a9[K],a4,q,a5)local aj=encode_value(self,tostring(K),a4,q,a5)table.insert(ai,string.format("%s:%s",aj,ah))end;a6="{"..table.concat(ai,",").."}"end else a6="[]"end;a4[X]=false;return a6 end end;function OBJDEF:encode(R,q)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onEncodeError("JSON:encode must be called in method format",q)end;return encode_value(self,R,{},q,nil)end;function OBJDEF:encode_pretty(R,q)if type(self)~='table'or self.__index~=OBJDEF then OBJDEF:onEncodeError("JSON:encode_pretty must be called in method format",q)end;return encode_value(self,R,{},q,"")end;function OBJDEF.__tostring()return"JSON encode/decode package"end;OBJDEF.__index=OBJDEF;function OBJDEF:new(ak)local new={}if ak then for K,P in pairs(ak)do new[K]=P end end;return setmetatable(new,OBJDEF)end;return OBJDEF:new()